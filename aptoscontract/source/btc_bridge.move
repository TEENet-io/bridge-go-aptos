module my_address::btc_bridgev3 {
    use std::error;
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    use aptos_framework::account;
    use aptos_framework::event;
    use my_address::btc_tokenv3;

    /// @notice Public key of the secret that is generated by the threshold
    ///         Schnorr signature scheme. The partial secrets are used by
    ///         bridge nodes to perform an m-out-of-n threshold signature.
    struct BridgeConfig has key {
        // pk: vector<u8>,
        admin: address,
        fee: u64,
        fee_account: address
    }

    /// @notice Mapping to keep track of minted BTC tokens
    struct MintedTransactions has key {
        minted: vector<String>,
    }

    /// @notice Mapping to keep track of prepared redeem requests
    struct PreparedRedeems has key {
        prepared: vector<String>,
    }

    /// @notice Mapping to keep track of spendable outpoints having been used
    struct UsedBtcTxIds has key {
        used: vector<String>,
    }

    /// Bridge events
    struct BridgeEvents has key {
        mint_events: event::EventHandle<MintEvent>,
        redeem_request_events: event::EventHandle<RedeemRequestEvent>,
        redeem_prepare_events: event::EventHandle<RedeemPrepareEvent>,
    }

    /// Event emitted when BTC is minted on Aptos
    struct MintEvent has drop, store {
        btc_tx_id: String,
        receiver: address,
        amount: u64,
    }

    /// Event emitted when a redeem request is made
    struct RedeemRequestEvent has drop, store {
        sender: address,
        amount: u64,
        receiver: String,
    }

    /// Event emitted when a redeem is prepared
    struct RedeemPrepareEvent has drop, store {
        RequestTxhash: String,
        Requester: address,
        Receiver: String,
        Amount: u64,
        OutpointTxIds: vector<String>,
        OutpointIdxs: vector<u64>,
    }

    // Error codes
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_ALREADY_INITIALIZED: u64 = 2;
    const E_ZERO_APTOS_ADDRESS: u64 = 3;
    const E_ZERO_FEE: u64 = 4;
    const E_ALREADY_MINTED: u64 = 5;
    const E_AMOUNT_SMALLER_THAN_FEE: u64 = 6;
    const E_INVALID_SCHNORR_SIGNATURE: u64 = 7;
    const E_ALREADY_PREPARED: u64 = 8;
    const E_ZERO_APTOS_TX_HASH: u64 = 9;
    const E_EMPTY_STRING: u64 = 10;
    const E_ZERO_AMOUNT: u64 = 11;
    const E_EMPTY_OUTPOINT_TX_IDS: u64 = 12;
    const E_EMPTY_OUTPOINT_IDXS: u64 = 13;
    const E_OUTPOINT_TX_IDS_AND_OUTPOINT_IDXS_LENGTH_MISMATCH: u64 = 14;
    const E_ZERO_OUTPOINT_TX_ID: u64 = 15;
    const E_BTC_TX_ID_ALREADY_USED: u64 = 16;

    /// Initialize the bridge with initial configuration
    public entry fun initialize(
        admin: &signer,
        // pk: vector<u8>,
        fee_account: address,
        fee: u64
    ) {
        let admin_addr = signer::address_of(admin);
        
        // Ensure the bridge hasn't been initialized
        assert!(!exists<BridgeConfig>(admin_addr), error::already_exists(E_ALREADY_INITIALIZED));
        
        // Validate fee account
        assert!(fee_account != @0x0, error::invalid_argument(E_ZERO_APTOS_ADDRESS));
        
        // Validate fee
        assert!(fee > 0, error::invalid_argument(E_ZERO_FEE));
        
        // Initialize bridge config
        move_to(admin, BridgeConfig {
            // pk,
            admin: admin_addr,
            fee,
            fee_account,
        });
        
        // Initialize tracking structures
        move_to(admin, MintedTransactions {
            minted: vector::empty<String>(),
        });
        
        move_to(admin, PreparedRedeems {
            prepared: vector::empty<String>(),
        });
        
        move_to(admin, UsedBtcTxIds {
            used: vector::empty<String>(),
        });
        
        // Initialize bridge events
        move_to(admin, BridgeEvents {
            mint_events: account::new_event_handle<MintEvent>(admin),
            redeem_request_events: account::new_event_handle<RedeemRequestEvent>(admin),
            redeem_prepare_events: account::new_event_handle<RedeemPrepareEvent>(admin),
        });
        
        // Initialize the BTC token
        btc_tokenv3::initialize_module(admin);
    }

    // /// Get the registered public key
    // public fun pk(): vector<u8> acquires BridgeConfig {
    //     borrow_global<BridgeConfig>(@my_address).pk
    // }

    /// Get the bridge fee
    public fun fee(): u64 acquires BridgeConfig {
        borrow_global<BridgeConfig>(@my_address).fee
    }

    /// Get the fee account address
    public fun fee_account(): address acquires BridgeConfig {
        borrow_global<BridgeConfig>(@my_address).fee_account
    }

    /// Mint BTC tokens and transfer to the receiver.
    /// It requires a valid Schnorr signature generated
    /// by m (out of n) bridge nodes via the threshold
    /// Schnorr signature scheme.
    public entry fun mint(
        admin: &signer,
        btc_tx_id: String,
        receiver: address,
        amount: u64,
        // rx: u64,
        // s: u64
    ) acquires BridgeConfig, MintedTransactions, BridgeEvents {
        let admin_addr = signer::address_of(admin);
        let bridge_config = borrow_global<BridgeConfig>(@my_address);
        
        // Ensure caller is admin
        assert!(admin_addr == bridge_config.admin, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Validate receiver
        // assert!(receiver != @0x0, error::invalid_argument(E_ZERO_APTOS_ADDRESS));
        
        // Validate amount
        assert!(amount > bridge_config.fee, error::invalid_argument(E_AMOUNT_SMALLER_THAN_FEE));
        
        // Check if already minted
        let minted_txs = borrow_global_mut<MintedTransactions>(@my_address);
        let i = 0;
        let len = vector::length(&minted_txs.minted);
        let already_minted = false;
        
        while (i < len) {
            if (*vector::borrow(&minted_txs.minted, i) == btc_tx_id) {
                already_minted = true;
                break;
            };
            i = i + 1;
        };
        
        assert!(!already_minted, error::invalid_argument(E_ALREADY_MINTED));
        
        // In a real implementation, we would verify the Schnorr signature here
        // For simplicity, we'll assume the signature is valid
        // verify_schnorr_signature(bridge_config.pk, rx, s, btc_tx_id, receiver, amount);
        
        // Mint tokens - recipient gets amount minus fee
        let recipient_amount = amount - bridge_config.fee;
        btc_tokenv3::mint_tokens(admin, receiver, amount, btc_tx_id);
        
        // Mark the btc_tx_id as minted
        vector::push_back(&mut minted_txs.minted, btc_tx_id);
        
        // Emit mint event
        let bridge_events = borrow_global_mut<BridgeEvents>(@my_address);
        event::emit_event(&mut bridge_events.mint_events, MintEvent {
            btc_tx_id,
            receiver,
            amount: recipient_amount,
        });
    }

    /// Request to redeem BTC. It emits an event to notify bridge
    /// nodes and burn BTC tokens. The function is performed by users who
    /// want to redeem BTC.
    public entry fun redeem_request(
        user: &signer,
        amount: u64,
        receiver: String
    ) acquires BridgeConfig, BridgeEvents {
        let user_addr = signer::address_of(user);
        let bridge_config = borrow_global<BridgeConfig>(@my_address);
        
        // Validate amount
        assert!(amount > bridge_config.fee, error::invalid_argument(E_AMOUNT_SMALLER_THAN_FEE));
        
        // Charge fee and burn tokens
        // The fee is transferred to fee_account, and the rest is burned
        let fee = bridge_config.fee;
        // let burn_amount = amount - fee;
        
        // Transfer fee to fee account
        btc_tokenv3::transfer(user, bridge_config.fee_account, amount);
        
        // Burn the remaining tokens with BTC address
        btc_tokenv3::burn_from(user_addr, amount, receiver);
        
        // Emit redeem request event
        let bridge_events = borrow_global_mut<BridgeEvents>(@my_address);
        event::emit_event(&mut bridge_events.redeem_request_events, RedeemRequestEvent {
            sender: user_addr,
            amount,
            receiver,
        });
    }

    /// Prepare to redeem BTC. The function is performed by bridge
    /// nodes via m-out-of-n threshold Schnorr signature scheme.
    public entry fun redeem_prepare(
        admin: &signer,
        redeem_request_tx_hash: String,
        requester: address,
        receiver: String,
        amount: u64,
        outpoint_tx_ids: vector<String>,
        outpoint_idxs: vector<u64>,
        // rx: u64,
        // s: u64
    ) acquires BridgeConfig, PreparedRedeems, UsedBtcTxIds, BridgeEvents {
        let admin_addr = signer::address_of(admin);
        let bridge_config = borrow_global<BridgeConfig>(@my_address);
                
        // Ensure caller is admin
        assert!(admin_addr == bridge_config.admin, error::permission_denied(E_NOT_AUTHORIZED));
        
        // Validate tx hash
        assert!(string::length(&redeem_request_tx_hash) > 0, error::invalid_argument(E_ZERO_APTOS_TX_HASH));
        
        // Check if already prepared
        let prepared_redeems = borrow_global_mut<PreparedRedeems>(@my_address);
        let i = 0;
        let len = vector::length(&prepared_redeems.prepared);
        let already_prepared = false;
        
        while (i < len) {
            if (*vector::borrow(&prepared_redeems.prepared, i) == redeem_request_tx_hash) {
                already_prepared = true;
                break;
            };
            i = i + 1;
        };
        
        assert!(!already_prepared, error::invalid_argument(E_ALREADY_PREPARED));
        
        // Validate requester
        assert!(requester != @0x0, error::invalid_argument(E_ZERO_APTOS_ADDRESS));
        
        // Validate receiver
        assert!(string::length(&receiver) > 0, error::invalid_argument(E_EMPTY_STRING));
        
        // Validate amount
        assert!(amount > 0, error::invalid_argument(E_ZERO_AMOUNT));
        
        // Validate outpoint tx ids
        assert!(vector::length(&outpoint_tx_ids) > 0, error::invalid_argument(E_EMPTY_OUTPOINT_TX_IDS));
        
        // Validate outpoint idxs
        assert!(vector::length(&outpoint_idxs) > 0, error::invalid_argument(E_EMPTY_OUTPOINT_IDXS));
        
        // Validate outpoint tx ids and outpoint idxs length mismatch
        assert!(vector::length(&outpoint_tx_ids) == vector::length(&outpoint_idxs), 
            error::invalid_argument(E_OUTPOINT_TX_IDS_AND_OUTPOINT_IDXS_LENGTH_MISMATCH));
        
        // Validate each outpoint tx id and mark as used
        let used_btc_tx_ids = borrow_global_mut<UsedBtcTxIds>(@my_address);
        i = 0;
        while (i < vector::length(&outpoint_tx_ids)) {
            let outpoint_tx_id = vector::borrow(&outpoint_tx_ids, i);
            
            // Check if tx id is valid (not empty)
            assert!(string::length(outpoint_tx_id) > 0, error::invalid_argument(E_ZERO_OUTPOINT_TX_ID));
            
            // Check if tx id is already used
            let j = 0;
            let tx_id_used = false;
            while (j < vector::length(&used_btc_tx_ids.used)) {
                if (*vector::borrow(&used_btc_tx_ids.used, j) == *outpoint_tx_id) {
                    tx_id_used = true;
                    break;
                };
                j = j + 1;
            };
            assert!(!tx_id_used, error::invalid_argument(E_BTC_TX_ID_ALREADY_USED));
            
            i = i + 1;
        };
        
        // In a real implementation, we would verify the Schnorr signature here
        // verify_schnorr_signature(bridge_config.pk, rx, s, hash_of_data);
        
        // Mark redeem request as prepared
        vector::push_back(&mut prepared_redeems.prepared, redeem_request_tx_hash);
        
        // Mark all outpoint tx ids as used
        i = 0;
        while (i < vector::length(&outpoint_tx_ids)) {
            vector::push_back(&mut used_btc_tx_ids.used, *vector::borrow(&outpoint_tx_ids, i));
            i = i + 1;
        };
        
        // Emit redeem prepared event
        let bridge_events = borrow_global_mut<BridgeEvents>(@my_address);
        event::emit_event(&mut bridge_events.redeem_prepare_events, RedeemPrepareEvent {
            RequestTxhash: redeem_request_tx_hash,
            Requester: requester,
            Receiver: receiver,
            Amount: amount,
            OutpointTxIds: outpoint_tx_ids,
            OutpointIdxs: outpoint_idxs
        });
    }


    /// @notice Check if TWBTC token are minted
    /// @param  btc_tx_id tx id of a spendable outpoint
    /// @return bool
    public fun is_minted(btc_tx_id: String): bool acquires MintedTransactions {
        let minted_txs = borrow_global<MintedTransactions>(@my_address);
        let i = 0;
        let len = vector::length(&minted_txs.minted);
        let found = false;
        while (i < len) {
            if (*vector::borrow(&minted_txs.minted, i) == btc_tx_id) {
                found = true;
                break;
            };
            i = i + 1;
        }; 
        found
    }

    /// @notice Check if the redeem request is prepared
    /// @param  tx_hash Hash of the redeem request tx
    /// @return bool
    public fun is_prepared(tx_hash: String): bool acquires PreparedRedeems {
        let prepared_redeems = borrow_global<PreparedRedeems>(@my_address);
        let i = 0;
        let len = vector::length(&prepared_redeems.prepared);
        let found = false;
        while (i < len) {
            if (*vector::borrow(&prepared_redeems.prepared, i) == tx_hash) {
                found = true;
                break;
            };
            i = i + 1;
        };
        found
    }

    /// @notice Check if the BTC tx id has been used for prepare a redeem
    /// @param  btc_tx_id tx id of a spendable outpoint
    /// @return bool
    public fun is_used(btc_tx_id: String): bool acquires UsedBtcTxIds {
        let used_btc_tx_ids = borrow_global<UsedBtcTxIds>(@my_address);
        let i = 0;
        let len = vector::length(&used_btc_tx_ids.used);
        let found = false;
        while (i < len) {
            if (*vector::borrow(&used_btc_tx_ids.used, i) == btc_tx_id) {
                found = true;
                break;
            };
            i = i + 1;
        };
        found
    }

        
        

    



}

